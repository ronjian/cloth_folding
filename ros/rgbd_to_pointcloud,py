#!/usr/bin/env python
import rospy
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge
import open3d as o3d
import numpy as np
import cv2

class RGBDToPointCloud:
    def __init__(self):
        rospy.init_node('rgbd_to_pointcloud', anonymous=True)
        
        # 初始化CV桥
        self.bridge = CvBridge()
        
        # 初始化Open3D可视化
        self.pcd = o3d.geometry.PointCloud()
        
        # 相机参数
        self.camera_info = None
        self.K = None  # 内参矩阵
        self.width = None
        self.height = None
        
        # 订阅话题
        rospy.Subscriber('/rgb', Image, self.rgb_callback)
        rospy.Subscriber('/depth', Image, self.depth_callback)
        rospy.Subscriber('/camera_info', CameraInfo, self.camera_info_callback)
        
        # 存储最新数据
        self.latest_rgb = None
        self.latest_depth = None
        
        # 更新频率
        self.rate = rospy.Rate(30)  # 30Hz
        
    def camera_info_callback(self, msg):
        """处理相机信息"""
        if self.camera_info is None:
            self.camera_info = msg
            self.width = msg.width
            self.height = msg.height
            self.K = np.array(msg.K).reshape(3, 3)
            rospy.loginfo("Received camera info")
    
    def rgb_callback(self, msg):
        """处理RGB图像"""
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
            self.latest_rgb = cv_image
            rospy.loginfo("Received RGB image")
        except Exception as e:
            rospy.logerr("RGB callback error: %s", str(e))
    
    def depth_callback(self, msg):
        """处理深度图像"""
        try:
            cv_image = self.bridge.imgmsg_to_cv2(msg, "passthrough")
            self.latest_depth = cv_image
            rospy.loginfo("Received depth image")
        except Exception as e:
            rospy.logerr("Depth callback error: %s", str(e))
    
    def create_pointcloud(self, rgb, depth):
        """从RGB和深度图像创建点云"""
        if self.K is None or rgb is None or depth is None:
            return None
        
        # 确保图像尺寸匹配
        if rgb.shape[0] != depth.shape[0] or rgb.shape[1] != depth.shape[1]:
            rospy.logwarn("RGB and depth image dimensions don't match")
            return None
        
        # 创建Open3D RGBD图像
        rgb = cv2.cvtColor(rgb, cv2.COLOR_BGR2RGB)  # Open3D需要RGB格式
        rgb_o3d = o3d.geometry.Image(rgb)
        depth_o3d = o3d.geometry.Image(depth.astype(np.float32))
        
        # 创建RGBD图像
        rgbd_image = o3d.geometry.RGBDImage.create_from_color_and_depth(
            rgb_o3d, depth_o3d, 
            depth_scale=1.0, 
            depth_trunc=10.0,  # 截断深度为3米
            convert_rgb_to_intensity=False)
        
        # 创建点云
        intrinsic = o3d.camera.PinholeCameraIntrinsic()
        intrinsic.set_intrinsics(
            width=self.width,
            height=self.height,
            fx=self.K[0, 0],
            fy=self.K[1, 1],
            cx=self.K[0, 2],
            cy=self.K[1, 2])
        
        pcd = o3d.geometry.PointCloud.create_from_rgbd_image(
            rgbd_image, intrinsic)
        
        # 转换坐标系，使点云朝前
        pcd.transform([[1, 0, 0, 0],
                       [0, -1, 0, 0],
                       [0, 0, -1, 0],
                       [0, 0, 0, 1]])
        
        return pcd
    
    def run(self):
        """主循环"""
        while not rospy.is_shutdown():
            if self.latest_rgb is not None and self.latest_depth is not None and self.K is not None:
                try:
                    # 创建点云
                    pcd = self.create_pointcloud(self.latest_rgb, self.latest_depth)
                    
                    if pcd is not None:
                        rospy.loginfo("Point cloud created")
                        # 更新可视化
                        self.pcd.points = pcd.points
                        self.pcd.colors = pcd.colors
                        o3d.io.write_point_cloud("tmp.pcd", self.pcd)  # PCD格式
                except Exception as e:
                    rospy.logerr("Error in point cloud creation: %s", str(e))
            
            self.rate.sleep()
        
if __name__ == '__main__':
    try:
        node = RGBDToPointCloud()
        node.run()
    except rospy.ROSInterruptException:
        pass